package archive

//
//// Code generated by github.com/tinylib/msgp DO NOT EDIT.
//
//import (
//	"github.com/annchain/OG/common/math"
//	"github.com/tinylib/msgp/msgp"
//)
//
//// DecodeMsg implements msgp.Decodable
//func (z *RawActionTx) DecodeMsg(dc *msgp.Reader) (err error) {
//	var zb0001 uint32
//	zb0001, err = dc.ReadArrayHeader()
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if zb0001 != 3 {
//		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
//		return
//	}
//	err = TxBase.DecodeMsg(dc)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	z.Action, err = dc.ReadUint8()
//	if err != nil {
//		err = msgp.WrapError(err, "Action")
//		return
//	}
//	err = z.ActionData.DecodeMsg(dc)
//	if err != nil {
//		err = msgp.WrapError(err, "ActionData")
//		return
//	}
//	return
//}
//
//// EncodeMsg implements msgp.Encodable
//func (z *RawActionTx) EncodeMsg(en *msgp.Writer) (err error) {
//	// array header, size 3
//	err = en.Append(0x93)
//	if err != nil {
//		return
//	}
//	err = TxBase.EncodeMsg(en)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	err = en.WriteUint8(z.Action)
//	if err != nil {
//		err = msgp.WrapError(err, "Action")
//		return
//	}
//	err = z.ActionData.EncodeMsg(en)
//	if err != nil {
//		err = msgp.WrapError(err, "ActionData")
//		return
//	}
//	return
//}
//
//// MarshalMsg implements msgp.Marshaler
//func (z *RawActionTx) MarshalMsg(b []byte) (o []byte, err error) {
//	o = msgp.Require(b, z.Msgsize())
//	// array header, size 3
//	o = append(o, 0x93)
//	o, err = TxBase.MarshalMsg(o)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	o = msgp.AppendUint8(o, z.Action)
//	o, err = z.ActionData.MarshalMsg(o)
//	if err != nil {
//		err = msgp.WrapError(err, "ActionData")
//		return
//	}
//	return
//}
//
//// UnmarshalMsg implements msgp.Unmarshaler
//func (z *RawActionTx) UnmarshalMsg(bts []byte) (o []byte, err error) {
//	var zb0001 uint32
//	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if zb0001 != 3 {
//		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
//		return
//	}
//	bts, err = TxBase.UnmarshalMsg(bts)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	z.Action, bts, err = msgp.ReadUint8Bytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err, "Action")
//		return
//	}
//	bts, err = z.ActionData.UnmarshalMsg(bts)
//	if err != nil {
//		err = msgp.WrapError(err, "ActionData")
//		return
//	}
//	o = bts
//	return
//}
//
//// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
//func (z *RawActionTx) Msgsize() (s int) {
//	s = 1 + TxBase.Msgsize() + msgp.Uint8Size + z.ActionData.Msgsize()
//	return
//}
//
//// DecodeMsg implements msgp.Decodable
//func (z *RawActionTxs) DecodeMsg(dc *msgp.Reader) (err error) {
//	var zb0002 uint32
//	zb0002, err = dc.ReadArrayHeader()
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if cap((*z)) >= int(zb0002) {
//		(*z) = (*z)[:zb0002]
//	} else {
//		(*z) = make(RawActionTxs, zb0002)
//	}
//	for zb0001 := range *z {
//		if dc.IsNil() {
//			err = dc.ReadNil()
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//			(*z)[zb0001] = nil
//		} else {
//			if (*z)[zb0001] == nil {
//				(*z)[zb0001] = new(RawActionTx)
//			}
//			var zb0003 uint32
//			zb0003, err = dc.ReadArrayHeader()
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//			if zb0003 != 3 {
//				err = msgp.ArrayError{Wanted: 3, Got: zb0003}
//				return
//			}
//			err = TxBase.DecodeMsg(dc)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001, "TxBase")
//				return
//			}
//			(*z)[zb0001].Action, err = dc.ReadUint8()
//			if err != nil {
//				err = msgp.WrapError(err, zb0001, "Action")
//				return
//			}
//			err = (*z)[zb0001].ActionData.DecodeMsg(dc)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001, "ActionData")
//				return
//			}
//		}
//	}
//	return
//}
//
//// EncodeMsg implements msgp.Encodable
//func (z RawActionTxs) EncodeMsg(en *msgp.Writer) (err error) {
//	err = en.WriteArrayHeader(uint32(len(z)))
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	for zb0004 := range z {
//		if z[zb0004] == nil {
//			err = en.WriteNil()
//			if err != nil {
//				return
//			}
//		} else {
//			// array header, size 3
//			err = en.Append(0x93)
//			if err != nil {
//				return
//			}
//			err = TxBase.EncodeMsg(en)
//			if err != nil {
//				err = msgp.WrapError(err, zb0004, "TxBase")
//				return
//			}
//			err = en.WriteUint8(z[zb0004].Action)
//			if err != nil {
//				err = msgp.WrapError(err, zb0004, "Action")
//				return
//			}
//			err = z[zb0004].ActionData.EncodeMsg(en)
//			if err != nil {
//				err = msgp.WrapError(err, zb0004, "ActionData")
//				return
//			}
//		}
//	}
//	return
//}
//
//// MarshalMsg implements msgp.Marshaler
//func (z RawActionTxs) MarshalMsg(b []byte) (o []byte, err error) {
//	o = msgp.Require(b, z.Msgsize())
//	o = msgp.AppendArrayHeader(o, uint32(len(z)))
//	for zb0004 := range z {
//		if z[zb0004] == nil {
//			o = msgp.AppendNil(o)
//		} else {
//			// array header, size 3
//			o = append(o, 0x93)
//			o, err = TxBase.MarshalMsg(o)
//			if err != nil {
//				err = msgp.WrapError(err, zb0004, "TxBase")
//				return
//			}
//			o = msgp.AppendUint8(o, z[zb0004].Action)
//			o, err = z[zb0004].ActionData.MarshalMsg(o)
//			if err != nil {
//				err = msgp.WrapError(err, zb0004, "ActionData")
//				return
//			}
//		}
//	}
//	return
//}
//
//// UnmarshalMsg implements msgp.Unmarshaler
//func (z *RawActionTxs) UnmarshalMsg(bts []byte) (o []byte, err error) {
//	var zb0002 uint32
//	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if cap((*z)) >= int(zb0002) {
//		(*z) = (*z)[:zb0002]
//	} else {
//		(*z) = make(RawActionTxs, zb0002)
//	}
//	for zb0001 := range *z {
//		if msgp.IsNil(bts) {
//			bts, err = msgp.ReadNilBytes(bts)
//			if err != nil {
//				return
//			}
//			(*z)[zb0001] = nil
//		} else {
//			if (*z)[zb0001] == nil {
//				(*z)[zb0001] = new(RawActionTx)
//			}
//			var zb0003 uint32
//			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//			if zb0003 != 3 {
//				err = msgp.ArrayError{Wanted: 3, Got: zb0003}
//				return
//			}
//			bts, err = TxBase.UnmarshalMsg(bts)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001, "TxBase")
//				return
//			}
//			(*z)[zb0001].Action, bts, err = msgp.ReadUint8Bytes(bts)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001, "Action")
//				return
//			}
//			bts, err = (*z)[zb0001].ActionData.UnmarshalMsg(bts)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001, "ActionData")
//				return
//			}
//		}
//	}
//	o = bts
//	return
//}
//
//// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
//func (z RawActionTxs) Msgsize() (s int) {
//	s = msgp.ArrayHeaderSize
//	for zb0004 := range z {
//		if z[zb0004] == nil {
//			s += msgp.NilSize
//		} else {
//			s += 1 + TxBase.Msgsize() + msgp.Uint8Size + z[zb0004].ActionData.Msgsize()
//		}
//	}
//	return
//}
//
//// DecodeMsg implements msgp.Decodable
//func (z *RawSequencer) DecodeMsg(dc *msgp.Reader) (err error) {
//	var zb0001 uint32
//	zb0001, err = dc.ReadArrayHeader()
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if zb0001 != 4 {
//		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
//		return
//	}
//	err = TxBase.DecodeMsg(dc)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	z.Signature, err = dc.ReadBytes(z.Signature)
//	if err != nil {
//		err = msgp.WrapError(err, "Signature")
//		return
//	}
//	z.PublicKey, err = dc.ReadBytes(z.PublicKey)
//	if err != nil {
//		err = msgp.WrapError(err, "PublicKey")
//		return
//	}
//	err = z.StateRoot.DecodeMsg(dc)
//	if err != nil {
//		err = msgp.WrapError(err, "StateRoot")
//		return
//	}
//	return
//}
//
//// EncodeMsg implements msgp.Encodable
//func (z *RawSequencer) EncodeMsg(en *msgp.Writer) (err error) {
//	// array header, size 4
//	err = en.Append(0x94)
//	if err != nil {
//		return
//	}
//	err = TxBase.EncodeMsg(en)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	err = en.WriteBytes(z.Signature)
//	if err != nil {
//		err = msgp.WrapError(err, "Signature")
//		return
//	}
//	err = en.WriteBytes(z.PublicKey)
//	if err != nil {
//		err = msgp.WrapError(err, "PublicKey")
//		return
//	}
//	err = z.StateRoot.EncodeMsg(en)
//	if err != nil {
//		err = msgp.WrapError(err, "StateRoot")
//		return
//	}
//	return
//}
//
//// MarshalMsg implements msgp.Marshaler
//func (z *RawSequencer) MarshalMsg(b []byte) (o []byte, err error) {
//	o = msgp.Require(b, z.Msgsize())
//	// array header, size 4
//	o = append(o, 0x94)
//	o, err = TxBase.MarshalMsg(o)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	o = msgp.AppendBytes(o, z.Signature)
//	o = msgp.AppendBytes(o, z.PublicKey)
//	o, err = z.StateRoot.MarshalMsg(o)
//	if err != nil {
//		err = msgp.WrapError(err, "StateRoot")
//		return
//	}
//	return
//}
//
//// UnmarshalMsg implements msgp.Unmarshaler
//func (z *RawSequencer) UnmarshalMsg(bts []byte) (o []byte, err error) {
//	var zb0001 uint32
//	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if zb0001 != 4 {
//		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
//		return
//	}
//	bts, err = TxBase.UnmarshalMsg(bts)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	z.Signature, bts, err = msgp.ReadBytesBytes(bts, z.Signature)
//	if err != nil {
//		err = msgp.WrapError(err, "Signature")
//		return
//	}
//	z.PublicKey, bts, err = msgp.ReadBytesBytes(bts, z.PublicKey)
//	if err != nil {
//		err = msgp.WrapError(err, "PublicKey")
//		return
//	}
//	bts, err = z.StateRoot.UnmarshalMsg(bts)
//	if err != nil {
//		err = msgp.WrapError(err, "StateRoot")
//		return
//	}
//	o = bts
//	return
//}
//
//// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
//func (z *RawSequencer) Msgsize() (s int) {
//	s = 1 + TxBase.Msgsize() + msgp.BytesPrefixSize + len(z.Signature) + msgp.BytesPrefixSize + len(z.PublicKey) + z.StateRoot.Msgsize()
//	return
//}
//
//// DecodeMsg implements msgp.Decodable
//func (z *RawSequencers) DecodeMsg(dc *msgp.Reader) (err error) {
//	var zb0002 uint32
//	zb0002, err = dc.ReadArrayHeader()
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if cap((*z)) >= int(zb0002) {
//		(*z) = (*z)[:zb0002]
//	} else {
//		(*z) = make(RawSequencers, zb0002)
//	}
//	for zb0001 := range *z {
//		if dc.IsNil() {
//			err = dc.ReadNil()
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//			(*z)[zb0001] = nil
//		} else {
//			if (*z)[zb0001] == nil {
//				(*z)[zb0001] = new(RawSequencer)
//			}
//			err = (*z)[zb0001].DecodeMsg(dc)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//		}
//	}
//	return
//}
//
//// EncodeMsg implements msgp.Encodable
//func (z RawSequencers) EncodeMsg(en *msgp.Writer) (err error) {
//	err = en.WriteArrayHeader(uint32(len(z)))
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			err = en.WriteNil()
//			if err != nil {
//				return
//			}
//		} else {
//			err = z[zb0003].EncodeMsg(en)
//			if err != nil {
//				err = msgp.WrapError(err, zb0003)
//				return
//			}
//		}
//	}
//	return
//}
//
//// MarshalMsg implements msgp.Marshaler
//func (z RawSequencers) MarshalMsg(b []byte) (o []byte, err error) {
//	o = msgp.Require(b, z.Msgsize())
//	o = msgp.AppendArrayHeader(o, uint32(len(z)))
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			o = msgp.AppendNil(o)
//		} else {
//			o, err = z[zb0003].MarshalMsg(o)
//			if err != nil {
//				err = msgp.WrapError(err, zb0003)
//				return
//			}
//		}
//	}
//	return
//}
//
//// UnmarshalMsg implements msgp.Unmarshaler
//func (z *RawSequencers) UnmarshalMsg(bts []byte) (o []byte, err error) {
//	var zb0002 uint32
//	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if cap((*z)) >= int(zb0002) {
//		(*z) = (*z)[:zb0002]
//	} else {
//		(*z) = make(RawSequencers, zb0002)
//	}
//	for zb0001 := range *z {
//		if msgp.IsNil(bts) {
//			bts, err = msgp.ReadNilBytes(bts)
//			if err != nil {
//				return
//			}
//			(*z)[zb0001] = nil
//		} else {
//			if (*z)[zb0001] == nil {
//				(*z)[zb0001] = new(RawSequencer)
//			}
//			bts, err = (*z)[zb0001].UnmarshalMsg(bts)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//		}
//	}
//	o = bts
//	return
//}
//
//// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
//func (z RawSequencers) Msgsize() (s int) {
//	s = msgp.ArrayHeaderSize
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			s += msgp.NilSize
//		} else {
//			s += z[zb0003].Msgsize()
//		}
//	}
//	return
//}
//
//// DecodeMsg implements msgp.Decodable
//func (z *RawTx) DecodeMsg(dc *msgp.Reader) (err error) {
//	var zb0001 uint32
//	zb0001, err = dc.ReadArrayHeader()
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if zb0001 != 5 {
//		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
//		return
//	}
//	err = TxBase.DecodeMsg(dc)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	err = z.To.DecodeMsg(dc)
//	if err != nil {
//		err = msgp.WrapError(err, "To")
//		return
//	}
//	if dc.IsNil() {
//		err = dc.ReadNil()
//		if err != nil {
//			err = msgp.WrapError(err, "Value")
//			return
//		}
//		z.Value = nil
//	} else {
//		if z.Value == nil {
//			z.Value = new(math.BigInt)
//		}
//		err = z.Value.DecodeMsg(dc)
//		if err != nil {
//			err = msgp.WrapError(err, "Value")
//			return
//		}
//	}
//	z.Data, err = dc.ReadBytes(z.Data)
//	if err != nil {
//		err = msgp.WrapError(err, "Data")
//		return
//	}
//	z.TokenId, err = dc.ReadInt32()
//	if err != nil {
//		err = msgp.WrapError(err, "TokenId")
//		return
//	}
//	return
//}
//
//// EncodeMsg implements msgp.Encodable
//func (z *RawTx) EncodeMsg(en *msgp.Writer) (err error) {
//	// array header, size 5
//	err = en.Append(0x95)
//	if err != nil {
//		return
//	}
//	err = TxBase.EncodeMsg(en)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	err = z.To.EncodeMsg(en)
//	if err != nil {
//		err = msgp.WrapError(err, "To")
//		return
//	}
//	if z.Value == nil {
//		err = en.WriteNil()
//		if err != nil {
//			return
//		}
//	} else {
//		err = z.Value.EncodeMsg(en)
//		if err != nil {
//			err = msgp.WrapError(err, "Value")
//			return
//		}
//	}
//	err = en.WriteBytes(z.Data)
//	if err != nil {
//		err = msgp.WrapError(err, "Data")
//		return
//	}
//	err = en.WriteInt32(z.TokenId)
//	if err != nil {
//		err = msgp.WrapError(err, "TokenId")
//		return
//	}
//	return
//}
//
//// MarshalMsg implements msgp.Marshaler
//func (z *RawTx) MarshalMsg(b []byte) (o []byte, err error) {
//	o = msgp.Require(b, z.Msgsize())
//	// array header, size 5
//	o = append(o, 0x95)
//	o, err = TxBase.MarshalMsg(o)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	o, err = z.To.MarshalMsg(o)
//	if err != nil {
//		err = msgp.WrapError(err, "To")
//		return
//	}
//	if z.Value == nil {
//		o = msgp.AppendNil(o)
//	} else {
//		o, err = z.Value.MarshalMsg(o)
//		if err != nil {
//			err = msgp.WrapError(err, "Value")
//			return
//		}
//	}
//	o = msgp.AppendBytes(o, z.Data)
//	o = msgp.AppendInt32(o, z.TokenId)
//	return
//}
//
//// UnmarshalMsg implements msgp.Unmarshaler
//func (z *RawTx) UnmarshalMsg(bts []byte) (o []byte, err error) {
//	var zb0001 uint32
//	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if zb0001 != 5 {
//		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
//		return
//	}
//	bts, err = TxBase.UnmarshalMsg(bts)
//	if err != nil {
//		err = msgp.WrapError(err, "TxBase")
//		return
//	}
//	bts, err = z.To.UnmarshalMsg(bts)
//	if err != nil {
//		err = msgp.WrapError(err, "To")
//		return
//	}
//	if msgp.IsNil(bts) {
//		bts, err = msgp.ReadNilBytes(bts)
//		if err != nil {
//			return
//		}
//		z.Value = nil
//	} else {
//		if z.Value == nil {
//			z.Value = new(math.BigInt)
//		}
//		bts, err = z.Value.UnmarshalMsg(bts)
//		if err != nil {
//			err = msgp.WrapError(err, "Value")
//			return
//		}
//	}
//	z.Data, bts, err = msgp.ReadBytesBytes(bts, z.Data)
//	if err != nil {
//		err = msgp.WrapError(err, "Data")
//		return
//	}
//	z.TokenId, bts, err = msgp.ReadInt32Bytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err, "TokenId")
//		return
//	}
//	o = bts
//	return
//}
//
//// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
//func (z *RawTx) Msgsize() (s int) {
//	s = 1 + TxBase.Msgsize() + z.To.Msgsize()
//	if z.Value == nil {
//		s += msgp.NilSize
//	} else {
//		s += z.Value.Msgsize()
//	}
//	s += msgp.BytesPrefixSize + len(z.Data) + msgp.Int32Size
//	return
//}
//
//// DecodeMsg implements msgp.Decodable
//func (z *RawTxs) DecodeMsg(dc *msgp.Reader) (err error) {
//	var zb0002 uint32
//	zb0002, err = dc.ReadArrayHeader()
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if cap((*z)) >= int(zb0002) {
//		(*z) = (*z)[:zb0002]
//	} else {
//		(*z) = make(RawTxs, zb0002)
//	}
//	for zb0001 := range *z {
//		if dc.IsNil() {
//			err = dc.ReadNil()
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//			(*z)[zb0001] = nil
//		} else {
//			if (*z)[zb0001] == nil {
//				(*z)[zb0001] = new(RawTx)
//			}
//			err = (*z)[zb0001].DecodeMsg(dc)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//		}
//	}
//	return
//}
//
//// EncodeMsg implements msgp.Encodable
//func (z RawTxs) EncodeMsg(en *msgp.Writer) (err error) {
//	err = en.WriteArrayHeader(uint32(len(z)))
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			err = en.WriteNil()
//			if err != nil {
//				return
//			}
//		} else {
//			err = z[zb0003].EncodeMsg(en)
//			if err != nil {
//				err = msgp.WrapError(err, zb0003)
//				return
//			}
//		}
//	}
//	return
//}
//
//// MarshalMsg implements msgp.Marshaler
//func (z RawTxs) MarshalMsg(b []byte) (o []byte, err error) {
//	o = msgp.Require(b, z.Msgsize())
//	o = msgp.AppendArrayHeader(o, uint32(len(z)))
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			o = msgp.AppendNil(o)
//		} else {
//			o, err = z[zb0003].MarshalMsg(o)
//			if err != nil {
//				err = msgp.WrapError(err, zb0003)
//				return
//			}
//		}
//	}
//	return
//}
//
//// UnmarshalMsg implements msgp.Unmarshaler
//func (z *RawTxs) UnmarshalMsg(bts []byte) (o []byte, err error) {
//	var zb0002 uint32
//	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if cap((*z)) >= int(zb0002) {
//		(*z) = (*z)[:zb0002]
//	} else {
//		(*z) = make(RawTxs, zb0002)
//	}
//	for zb0001 := range *z {
//		if msgp.IsNil(bts) {
//			bts, err = msgp.ReadNilBytes(bts)
//			if err != nil {
//				return
//			}
//			(*z)[zb0001] = nil
//		} else {
//			if (*z)[zb0001] == nil {
//				(*z)[zb0001] = new(RawTx)
//			}
//			bts, err = (*z)[zb0001].UnmarshalMsg(bts)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//		}
//	}
//	o = bts
//	return
//}
//
//// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
//func (z RawTxs) Msgsize() (s int) {
//	s = msgp.ArrayHeaderSize
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			s += msgp.NilSize
//		} else {
//			s += z[zb0003].Msgsize()
//		}
//	}
//	return
//}
//
//// DecodeMsg implements msgp.Decodable
//func (z *TxisMarshaler) DecodeMsg(dc *msgp.Reader) (err error) {
//	var zb0002 uint32
//	zb0002, err = dc.ReadArrayHeader()
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if cap((*z)) >= int(zb0002) {
//		(*z) = (*z)[:zb0002]
//	} else {
//		(*z) = make(TxisMarshaler, zb0002)
//	}
//	for zb0001 := range *z {
//		if dc.IsNil() {
//			err = dc.ReadNil()
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//			(*z)[zb0001] = nil
//		} else {
//			if (*z)[zb0001] == nil {
//				(*z)[zb0001] = new(RawTxMarshaler)
//			}
//			err = (*z)[zb0001].DecodeMsg(dc)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//		}
//	}
//	return
//}
//
//// EncodeMsg implements msgp.Encodable
//func (z TxisMarshaler) EncodeMsg(en *msgp.Writer) (err error) {
//	err = en.WriteArrayHeader(uint32(len(z)))
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			err = en.WriteNil()
//			if err != nil {
//				return
//			}
//		} else {
//			err = z[zb0003].EncodeMsg(en)
//			if err != nil {
//				err = msgp.WrapError(err, zb0003)
//				return
//			}
//		}
//	}
//	return
//}
//
//// MarshalMsg implements msgp.Marshaler
//func (z TxisMarshaler) MarshalMsg(b []byte) (o []byte, err error) {
//	o = msgp.Require(b, z.Msgsize())
//	o = msgp.AppendArrayHeader(o, uint32(len(z)))
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			o = msgp.AppendNil(o)
//		} else {
//			o, err = z[zb0003].MarshalMsg(o)
//			if err != nil {
//				err = msgp.WrapError(err, zb0003)
//				return
//			}
//		}
//	}
//	return
//}
//
//// UnmarshalMsg implements msgp.Unmarshaler
//func (z *TxisMarshaler) UnmarshalMsg(bts []byte) (o []byte, err error) {
//	var zb0002 uint32
//	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
//	if err != nil {
//		err = msgp.WrapError(err)
//		return
//	}
//	if cap((*z)) >= int(zb0002) {
//		(*z) = (*z)[:zb0002]
//	} else {
//		(*z) = make(TxisMarshaler, zb0002)
//	}
//	for zb0001 := range *z {
//		if msgp.IsNil(bts) {
//			bts, err = msgp.ReadNilBytes(bts)
//			if err != nil {
//				return
//			}
//			(*z)[zb0001] = nil
//		} else {
//			if (*z)[zb0001] == nil {
//				(*z)[zb0001] = new(RawTxMarshaler)
//			}
//			bts, err = (*z)[zb0001].UnmarshalMsg(bts)
//			if err != nil {
//				err = msgp.WrapError(err, zb0001)
//				return
//			}
//		}
//	}
//	o = bts
//	return
//}
//
//// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
//func (z TxisMarshaler) Msgsize() (s int) {
//	s = msgp.ArrayHeaderSize
//	for zb0003 := range z {
//		if z[zb0003] == nil {
//			s += msgp.NilSize
//		} else {
//			s += z[zb0003].Msgsize()
//		}
//	}
//	return
//}
