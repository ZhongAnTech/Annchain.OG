package discover

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Config) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			err = dc.Skip()
			if err != nil {
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Config) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 0
	err = en.Append(0x80)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Config) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 0
	o = append(o, 0x80)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Config) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			return
		}
		switch msgp.UnsafeString(field) {
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Config) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Findnode) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	err = z.Target.DecodeMsg(dc)
	if err != nil {
		return
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0002) {
		z.Rest = (z.Rest)[:zb0002]
	} else {
		z.Rest = make([][]byte, zb0002)
	}
	for za0001 := range z.Rest {
		z.Rest[za0001], err = dc.ReadBytes(z.Rest[za0001])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Findnode) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = z.Target.EncodeMsg(en)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0001 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0001])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Findnode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o, err = z.Target.MarshalMsg(o)
	if err != nil {
		return
	}
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0001 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Findnode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	bts, err = z.Target.UnmarshalMsg(bts)
	if err != nil {
		return
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0002) {
		z.Rest = (z.Rest)[:zb0002]
	} else {
		z.Rest = make([][]byte, zb0002)
	}
	for za0001 := range z.Rest {
		z.Rest[za0001], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0001])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Findnode) Msgsize() (s int) {
	s = 1 + z.Target.Msgsize() + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0001 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0001])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Neighbors) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Nodes) >= int(zb0002) {
		z.Nodes = (z.Nodes)[:zb0002]
	} else {
		z.Nodes = make([]RpcNode, zb0002)
	}
	for za0001 := range z.Nodes {
		err = z.Nodes[za0001].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0003) {
		z.Rest = (z.Rest)[:zb0003]
	} else {
		z.Rest = make([][]byte, zb0003)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], err = dc.ReadBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Neighbors) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Nodes)))
	if err != nil {
		return
	}
	for za0001 := range z.Nodes {
		err = z.Nodes[za0001].EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0002 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Neighbors) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Nodes)))
	for za0001 := range z.Nodes {
		o, err = z.Nodes[za0001].MarshalMsg(o)
		if err != nil {
			return
		}
	}
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0002 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Neighbors) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Nodes) >= int(zb0002) {
		z.Nodes = (z.Nodes)[:zb0002]
	} else {
		z.Nodes = make([]RpcNode, zb0002)
	}
	for za0001 := range z.Nodes {
		bts, err = z.Nodes[za0001].UnmarshalMsg(bts)
		if err != nil {
			return
		}
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0003) {
		z.Rest = (z.Rest)[:zb0003]
	} else {
		z.Rest = make([][]byte, zb0003)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0002])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Neighbors) Msgsize() (s int) {
	s = 1 + msgp.ArrayHeaderSize
	for za0001 := range z.Nodes {
		s += z.Nodes[za0001].Msgsize()
	}
	s += msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0002 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0002])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Ping) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 5 {
		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
		return
	}
	z.Version, err = dc.ReadUint()
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0002 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0002}
		return
	}
	z.From.IP, err = dc.ReadBytes(z.From.IP)
	if err != nil {
		return
	}
	z.From.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.From.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0003 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0003}
		return
	}
	z.To.IP, err = dc.ReadBytes(z.To.IP)
	if err != nil {
		return
	}
	z.To.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.To.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0004 uint32
	zb0004, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0004) {
		z.Rest = (z.Rest)[:zb0004]
	} else {
		z.Rest = make([][]byte, zb0004)
	}
	for za0001 := range z.Rest {
		z.Rest[za0001], err = dc.ReadBytes(z.Rest[za0001])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Ping) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 5
	err = en.Append(0x95)
	if err != nil {
		return
	}
	err = en.WriteUint(z.Version)
	if err != nil {
		return
	}
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.From.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.From.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.From.TCP)
	if err != nil {
		return
	}
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.To.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.To.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.To.TCP)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0001 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0001])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Ping) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 5
	o = append(o, 0x95)
	o = msgp.AppendUint(o, z.Version)
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, z.From.IP)
	o = msgp.AppendUint16(o, z.From.UDP)
	o = msgp.AppendUint16(o, z.From.TCP)
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, z.To.IP)
	o = msgp.AppendUint16(o, z.To.UDP)
	o = msgp.AppendUint16(o, z.To.TCP)
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0001 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Ping) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 5 {
		err = msgp.ArrayError{Wanted: 5, Got: zb0001}
		return
	}
	z.Version, bts, err = msgp.ReadUintBytes(bts)
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0002 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0002}
		return
	}
	z.From.IP, bts, err = msgp.ReadBytesBytes(bts, z.From.IP)
	if err != nil {
		return
	}
	z.From.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.From.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0003 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0003}
		return
	}
	z.To.IP, bts, err = msgp.ReadBytesBytes(bts, z.To.IP)
	if err != nil {
		return
	}
	z.To.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.To.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	var zb0004 uint32
	zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0004) {
		z.Rest = (z.Rest)[:zb0004]
	} else {
		z.Rest = make([][]byte, zb0004)
	}
	for za0001 := range z.Rest {
		z.Rest[za0001], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0001])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Ping) Msgsize() (s int) {
	s = 1 + msgp.UintSize + 1 + msgp.BytesPrefixSize + len(z.From.IP) + msgp.Uint16Size + msgp.Uint16Size + 1 + msgp.BytesPrefixSize + len(z.To.IP) + msgp.Uint16Size + msgp.Uint16Size + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0001 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0001])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Pong) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0002 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0002}
		return
	}
	z.To.IP, err = dc.ReadBytes(z.To.IP)
	if err != nil {
		return
	}
	z.To.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.To.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.ReplyTok, err = dc.ReadBytes(z.ReplyTok)
	if err != nil {
		return
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0003) {
		z.Rest = (z.Rest)[:zb0003]
	} else {
		z.Rest = make([][]byte, zb0003)
	}
	for za0001 := range z.Rest {
		z.Rest[za0001], err = dc.ReadBytes(z.Rest[za0001])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Pong) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	// array header, size 3
	err = en.Append(0x94, 0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.To.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.To.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.To.TCP)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.ReplyTok)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0001 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0001])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Pong) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	// array header, size 3
	o = append(o, 0x94, 0x93)
	o = msgp.AppendBytes(o, z.To.IP)
	o = msgp.AppendUint16(o, z.To.UDP)
	o = msgp.AppendUint16(o, z.To.TCP)
	o = msgp.AppendBytes(o, z.ReplyTok)
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0001 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0001])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Pong) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0002 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0002}
		return
	}
	z.To.IP, bts, err = msgp.ReadBytesBytes(bts, z.To.IP)
	if err != nil {
		return
	}
	z.To.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.To.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.ReplyTok, bts, err = msgp.ReadBytesBytes(bts, z.ReplyTok)
	if err != nil {
		return
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0003) {
		z.Rest = (z.Rest)[:zb0003]
	} else {
		z.Rest = make([][]byte, zb0003)
	}
	for za0001 := range z.Rest {
		z.Rest[za0001], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0001])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Pong) Msgsize() (s int) {
	s = 1 + 1 + msgp.BytesPrefixSize + len(z.To.IP) + msgp.Uint16Size + msgp.Uint16Size + msgp.BytesPrefixSize + len(z.ReplyTok) + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0001 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0001])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReadPacket) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 0 {
		err = msgp.ArrayError{Wanted: 0, Got: zb0001}
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ReadPacket) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 0
	err = en.Append(0x90)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ReadPacket) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 0
	o = append(o, 0x90)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReadPacket) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 0 {
		err = msgp.ArrayError{Wanted: 0, Got: zb0001}
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ReadPacket) Msgsize() (s int) {
	s = 1
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RpcEndpoint) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	z.IP, err = dc.ReadBytes(z.IP)
	if err != nil {
		return
	}
	z.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RpcEndpoint) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.TCP)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RpcEndpoint) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, z.IP)
	o = msgp.AppendUint16(o, z.UDP)
	o = msgp.AppendUint16(o, z.TCP)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RpcEndpoint) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	z.IP, bts, err = msgp.ReadBytesBytes(bts, z.IP)
	if err != nil {
		return
	}
	z.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RpcEndpoint) Msgsize() (s int) {
	s = 1 + msgp.BytesPrefixSize + len(z.IP) + msgp.Uint16Size + msgp.Uint16Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RpcNode) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	z.IP, err = dc.ReadBytes(z.IP)
	if err != nil {
		return
	}
	z.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	err = z.ID.DecodeMsg(dc)
	if err != nil {
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RpcNode) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.TCP)
	if err != nil {
		return
	}
	err = z.ID.EncodeMsg(en)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RpcNode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendBytes(o, z.IP)
	o = msgp.AppendUint16(o, z.UDP)
	o = msgp.AppendUint16(o, z.TCP)
	o, err = z.ID.MarshalMsg(o)
	if err != nil {
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RpcNode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	z.IP, bts, err = msgp.ReadBytesBytes(bts, z.IP)
	if err != nil {
		return
	}
	z.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	bts, err = z.ID.UnmarshalMsg(bts)
	if err != nil {
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RpcNode) Msgsize() (s int) {
	s = 1 + msgp.BytesPrefixSize + len(z.IP) + msgp.Uint16Size + msgp.Uint16Size + z.ID.Msgsize()
	return
}
