package discv5

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *CommonHash) DecodeMsg(dc *msgp.Reader) (err error) {
	err = dc.ReadExactBytes((z)[:])
	if err != nil {
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CommonHash) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteBytes((z)[:])
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CommonHash) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendBytes(o, (z)[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CommonHash) UnmarshalMsg(bts []byte) (o []byte, err error) {
	bts, err = msgp.ReadExactBytes(bts, (z)[:])
	if err != nil {
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CommonHash) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize + (32 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Findnode) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	err = dc.ReadExactBytes((z.Target)[:])
	if err != nil {
		return
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0002) {
		z.Rest = (z.Rest)[:zb0002]
	} else {
		z.Rest = make([][]byte, zb0002)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], err = dc.ReadBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Findnode) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Target)[:])
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0002 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Findnode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, (z.Target)[:])
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0002 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Findnode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	bts, err = msgp.ReadExactBytes(bts, (z.Target)[:])
	if err != nil {
		return
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0002) {
		z.Rest = (z.Rest)[:zb0002]
	} else {
		z.Rest = make([][]byte, zb0002)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0002])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Findnode) Msgsize() (s int) {
	s = 1 + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize)) + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0002 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0002])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *FindnodeHash) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	err = dc.ReadExactBytes((z.Target)[:])
	if err != nil {
		return
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0002) {
		z.Rest = (z.Rest)[:zb0002]
	} else {
		z.Rest = make([][]byte, zb0002)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], err = dc.ReadBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *FindnodeHash) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Target)[:])
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0002 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FindnodeHash) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, (z.Target)[:])
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0002 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FindnodeHash) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	bts, err = msgp.ReadExactBytes(bts, (z.Target)[:])
	if err != nil {
		return
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0002) {
		z.Rest = (z.Rest)[:zb0002]
	} else {
		z.Rest = make([][]byte, zb0002)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0002])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FindnodeHash) Msgsize() (s int) {
	s = 1 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0002 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0002])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Neighbors) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Nodes) >= int(zb0002) {
		z.Nodes = (z.Nodes)[:zb0002]
	} else {
		z.Nodes = make([]RpcNode, zb0002)
	}
	for za0001 := range z.Nodes {
		err = z.Nodes[za0001].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0003) {
		z.Rest = (z.Rest)[:zb0003]
	} else {
		z.Rest = make([][]byte, zb0003)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], err = dc.ReadBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Neighbors) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Nodes)))
	if err != nil {
		return
	}
	for za0001 := range z.Nodes {
		err = z.Nodes[za0001].EncodeMsg(en)
		if err != nil {
			return
		}
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0002 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Neighbors) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Nodes)))
	for za0001 := range z.Nodes {
		o, err = z.Nodes[za0001].MarshalMsg(o)
		if err != nil {
			return
		}
	}
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0002 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Neighbors) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Nodes) >= int(zb0002) {
		z.Nodes = (z.Nodes)[:zb0002]
	} else {
		z.Nodes = make([]RpcNode, zb0002)
	}
	for za0001 := range z.Nodes {
		bts, err = z.Nodes[za0001].UnmarshalMsg(bts)
		if err != nil {
			return
		}
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0003) {
		z.Rest = (z.Rest)[:zb0003]
	} else {
		z.Rest = make([][]byte, zb0003)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0002])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Neighbors) Msgsize() (s int) {
	s = 1 + msgp.ArrayHeaderSize
	for za0001 := range z.Nodes {
		s += z.Nodes[za0001].Msgsize()
	}
	s += msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0002 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0002])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Ping) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zb0001}
		return
	}
	z.Version, err = dc.ReadUint()
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0002 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0002}
		return
	}
	z.From.IP, err = dc.ReadBytes(z.From.IP)
	if err != nil {
		return
	}
	z.From.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.From.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0003 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0003}
		return
	}
	z.To.IP, err = dc.ReadBytes(z.To.IP)
	if err != nil {
		return
	}
	z.To.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.To.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	var zb0004 uint32
	zb0004, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Topics) >= int(zb0004) {
		z.Topics = (z.Topics)[:zb0004]
	} else {
		z.Topics = make([]string, zb0004)
	}
	for za0001 := range z.Topics {
		z.Topics[za0001], err = dc.ReadString()
		if err != nil {
			return
		}
	}
	var zb0005 uint32
	zb0005, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0005) {
		z.Rest = (z.Rest)[:zb0005]
	} else {
		z.Rest = make([][]byte, zb0005)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], err = dc.ReadBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Ping) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 6
	err = en.Append(0x96)
	if err != nil {
		return
	}
	err = en.WriteUint(z.Version)
	if err != nil {
		return
	}
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.From.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.From.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.From.TCP)
	if err != nil {
		return
	}
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.To.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.To.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.To.TCP)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Topics)))
	if err != nil {
		return
	}
	for za0001 := range z.Topics {
		err = en.WriteString(z.Topics[za0001])
		if err != nil {
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0002 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0002])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Ping) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 6
	o = append(o, 0x96)
	o = msgp.AppendUint(o, z.Version)
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, z.From.IP)
	o = msgp.AppendUint16(o, z.From.UDP)
	o = msgp.AppendUint16(o, z.From.TCP)
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, z.To.IP)
	o = msgp.AppendUint16(o, z.To.UDP)
	o = msgp.AppendUint16(o, z.To.TCP)
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Topics)))
	for za0001 := range z.Topics {
		o = msgp.AppendString(o, z.Topics[za0001])
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0002 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Ping) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 6 {
		err = msgp.ArrayError{Wanted: 6, Got: zb0001}
		return
	}
	z.Version, bts, err = msgp.ReadUintBytes(bts)
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0002 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0002}
		return
	}
	z.From.IP, bts, err = msgp.ReadBytesBytes(bts, z.From.IP)
	if err != nil {
		return
	}
	z.From.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.From.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0003 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0003}
		return
	}
	z.To.IP, bts, err = msgp.ReadBytesBytes(bts, z.To.IP)
	if err != nil {
		return
	}
	z.To.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.To.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	var zb0004 uint32
	zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Topics) >= int(zb0004) {
		z.Topics = (z.Topics)[:zb0004]
	} else {
		z.Topics = make([]string, zb0004)
	}
	for za0001 := range z.Topics {
		z.Topics[za0001], bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			return
		}
	}
	var zb0005 uint32
	zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0005) {
		z.Rest = (z.Rest)[:zb0005]
	} else {
		z.Rest = make([][]byte, zb0005)
	}
	for za0002 := range z.Rest {
		z.Rest[za0002], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0002])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Ping) Msgsize() (s int) {
	s = 1 + msgp.UintSize + 1 + msgp.BytesPrefixSize + len(z.From.IP) + msgp.Uint16Size + msgp.Uint16Size + 1 + msgp.BytesPrefixSize + len(z.To.IP) + msgp.Uint16Size + msgp.Uint16Size + msgp.Uint64Size + msgp.ArrayHeaderSize
	for za0001 := range z.Topics {
		s += msgp.StringPrefixSize + len(z.Topics[za0001])
	}
	s += msgp.ArrayHeaderSize
	for za0002 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0002])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Pong) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 7 {
		err = msgp.ArrayError{Wanted: 7, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0002 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0002}
		return
	}
	z.To.IP, err = dc.ReadBytes(z.To.IP)
	if err != nil {
		return
	}
	z.To.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.To.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.ReplyTok, err = dc.ReadBytes(z.ReplyTok)
	if err != nil {
		return
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	err = dc.ReadExactBytes((z.TopicHash)[:])
	if err != nil {
		return
	}
	z.TicketSerial, err = dc.ReadUint32()
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.WaitPeriods) >= int(zb0003) {
		z.WaitPeriods = (z.WaitPeriods)[:zb0003]
	} else {
		z.WaitPeriods = make([]uint32, zb0003)
	}
	for za0002 := range z.WaitPeriods {
		z.WaitPeriods[za0002], err = dc.ReadUint32()
		if err != nil {
			return
		}
	}
	var zb0004 uint32
	zb0004, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0004) {
		z.Rest = (z.Rest)[:zb0004]
	} else {
		z.Rest = make([][]byte, zb0004)
	}
	for za0003 := range z.Rest {
		z.Rest[za0003], err = dc.ReadBytes(z.Rest[za0003])
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Pong) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 7
	// array header, size 3
	err = en.Append(0x97, 0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.To.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.To.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.To.TCP)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.ReplyTok)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.TopicHash)[:])
	if err != nil {
		return
	}
	err = en.WriteUint32(z.TicketSerial)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WaitPeriods)))
	if err != nil {
		return
	}
	for za0002 := range z.WaitPeriods {
		err = en.WriteUint32(z.WaitPeriods[za0002])
		if err != nil {
			return
		}
	}
	err = en.WriteArrayHeader(uint32(len(z.Rest)))
	if err != nil {
		return
	}
	for za0003 := range z.Rest {
		err = en.WriteBytes(z.Rest[za0003])
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Pong) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 7
	// array header, size 3
	o = append(o, 0x97, 0x93)
	o = msgp.AppendBytes(o, z.To.IP)
	o = msgp.AppendUint16(o, z.To.UDP)
	o = msgp.AppendUint16(o, z.To.TCP)
	o = msgp.AppendBytes(o, z.ReplyTok)
	o = msgp.AppendUint64(o, z.Expiration)
	o = msgp.AppendBytes(o, (z.TopicHash)[:])
	o = msgp.AppendUint32(o, z.TicketSerial)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WaitPeriods)))
	for za0002 := range z.WaitPeriods {
		o = msgp.AppendUint32(o, z.WaitPeriods[za0002])
	}
	o = msgp.AppendArrayHeader(o, uint32(len(z.Rest)))
	for za0003 := range z.Rest {
		o = msgp.AppendBytes(o, z.Rest[za0003])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Pong) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 7 {
		err = msgp.ArrayError{Wanted: 7, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0002 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0002}
		return
	}
	z.To.IP, bts, err = msgp.ReadBytesBytes(bts, z.To.IP)
	if err != nil {
		return
	}
	z.To.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.To.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.ReplyTok, bts, err = msgp.ReadBytesBytes(bts, z.ReplyTok)
	if err != nil {
		return
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	bts, err = msgp.ReadExactBytes(bts, (z.TopicHash)[:])
	if err != nil {
		return
	}
	z.TicketSerial, bts, err = msgp.ReadUint32Bytes(bts)
	if err != nil {
		return
	}
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.WaitPeriods) >= int(zb0003) {
		z.WaitPeriods = (z.WaitPeriods)[:zb0003]
	} else {
		z.WaitPeriods = make([]uint32, zb0003)
	}
	for za0002 := range z.WaitPeriods {
		z.WaitPeriods[za0002], bts, err = msgp.ReadUint32Bytes(bts)
		if err != nil {
			return
		}
	}
	var zb0004 uint32
	zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Rest) >= int(zb0004) {
		z.Rest = (z.Rest)[:zb0004]
	} else {
		z.Rest = make([][]byte, zb0004)
	}
	for za0003 := range z.Rest {
		z.Rest[za0003], bts, err = msgp.ReadBytesBytes(bts, z.Rest[za0003])
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Pong) Msgsize() (s int) {
	s = 1 + 1 + msgp.BytesPrefixSize + len(z.To.IP) + msgp.Uint16Size + msgp.Uint16Size + msgp.BytesPrefixSize + len(z.ReplyTok) + msgp.Uint64Size + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + msgp.Uint32Size + msgp.ArrayHeaderSize + (len(z.WaitPeriods) * (msgp.Uint32Size)) + msgp.ArrayHeaderSize
	for za0003 := range z.Rest {
		s += msgp.BytesPrefixSize + len(z.Rest[za0003])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RpcEndpoint) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	z.IP, err = dc.ReadBytes(z.IP)
	if err != nil {
		return
	}
	z.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RpcEndpoint) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.TCP)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RpcEndpoint) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendBytes(o, z.IP)
	o = msgp.AppendUint16(o, z.UDP)
	o = msgp.AppendUint16(o, z.TCP)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RpcEndpoint) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	z.IP, bts, err = msgp.ReadBytesBytes(bts, z.IP)
	if err != nil {
		return
	}
	z.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RpcEndpoint) Msgsize() (s int) {
	s = 1 + msgp.BytesPrefixSize + len(z.IP) + msgp.Uint16Size + msgp.Uint16Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RpcNode) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	z.IP, err = dc.ReadBytes(z.IP)
	if err != nil {
		return
	}
	z.UDP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	z.TCP, err = dc.ReadUint16()
	if err != nil {
		return
	}
	err = dc.ReadExactBytes((z.ID)[:])
	if err != nil {
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RpcNode) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 4
	err = en.Append(0x94)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.IP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.UDP)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.TCP)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.ID)[:])
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RpcNode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 4
	o = append(o, 0x94)
	o = msgp.AppendBytes(o, z.IP)
	o = msgp.AppendUint16(o, z.UDP)
	o = msgp.AppendUint16(o, z.TCP)
	o = msgp.AppendBytes(o, (z.ID)[:])
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RpcNode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 4 {
		err = msgp.ArrayError{Wanted: 4, Got: zb0001}
		return
	}
	z.IP, bts, err = msgp.ReadBytesBytes(bts, z.IP)
	if err != nil {
		return
	}
	z.UDP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	z.TCP, bts, err = msgp.ReadUint16Bytes(bts)
	if err != nil {
		return
	}
	bts, err = msgp.ReadExactBytes(bts, (z.ID)[:])
	if err != nil {
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RpcNode) Msgsize() (s int) {
	s = 1 + msgp.BytesPrefixSize + len(z.IP) + msgp.Uint16Size + msgp.Uint16Size + msgp.ArrayHeaderSize + (64 * (msgp.ByteSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TopicNodes) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	err = dc.ReadExactBytes((z.Echo)[:])
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Nodes) >= int(zb0002) {
		z.Nodes = (z.Nodes)[:zb0002]
	} else {
		z.Nodes = make([]RpcNode, zb0002)
	}
	for za0002 := range z.Nodes {
		err = z.Nodes[za0002].DecodeMsg(dc)
		if err != nil {
			return
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TopicNodes) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteBytes((z.Echo)[:])
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Nodes)))
	if err != nil {
		return
	}
	for za0002 := range z.Nodes {
		err = z.Nodes[za0002].EncodeMsg(en)
		if err != nil {
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TopicNodes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o = msgp.AppendBytes(o, (z.Echo)[:])
	o = msgp.AppendArrayHeader(o, uint32(len(z.Nodes)))
	for za0002 := range z.Nodes {
		o, err = z.Nodes[za0002].MarshalMsg(o)
		if err != nil {
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TopicNodes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	bts, err = msgp.ReadExactBytes(bts, (z.Echo)[:])
	if err != nil {
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Nodes) >= int(zb0002) {
		z.Nodes = (z.Nodes)[:zb0002]
	} else {
		z.Nodes = make([]RpcNode, zb0002)
	}
	for za0002 := range z.Nodes {
		bts, err = z.Nodes[za0002].UnmarshalMsg(bts)
		if err != nil {
			return
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TopicNodes) Msgsize() (s int) {
	s = 1 + msgp.ArrayHeaderSize + (32 * (msgp.ByteSize)) + msgp.ArrayHeaderSize
	for za0002 := range z.Nodes {
		s += z.Nodes[za0002].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TopicQuery) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Topic, err = dc.ReadString()
	if err != nil {
		return
	}
	z.Expiration, err = dc.ReadUint64()
	if err != nil {
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TopicQuery) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 2
	err = en.Append(0x92)
	if err != nil {
		return
	}
	err = en.WriteString(z.Topic)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Expiration)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TopicQuery) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 2
	o = append(o, 0x92)
	o = msgp.AppendString(o, z.Topic)
	o = msgp.AppendUint64(o, z.Expiration)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TopicQuery) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 2 {
		err = msgp.ArrayError{Wanted: 2, Got: zb0001}
		return
	}
	z.Topic, bts, err = msgp.ReadStringBytes(bts)
	if err != nil {
		return
	}
	z.Expiration, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TopicQuery) Msgsize() (s int) {
	s = 1 + msgp.StringPrefixSize + len(z.Topic) + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TopicRegister) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, err = dc.ReadArrayHeader()
	if err != nil {
		return
	}
	if cap(z.Topics) >= int(zb0002) {
		z.Topics = (z.Topics)[:zb0002]
	} else {
		z.Topics = make([]string, zb0002)
	}
	for za0001 := range z.Topics {
		z.Topics[za0001], err = dc.ReadString()
		if err != nil {
			return
		}
	}
	z.Idx, err = dc.ReadUint()
	if err != nil {
		return
	}
	z.Pong, err = dc.ReadBytes(z.Pong)
	if err != nil {
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TopicRegister) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Topics)))
	if err != nil {
		return
	}
	for za0001 := range z.Topics {
		err = en.WriteString(z.Topics[za0001])
		if err != nil {
			return
		}
	}
	err = en.WriteUint(z.Idx)
	if err != nil {
		return
	}
	err = en.WriteBytes(z.Pong)
	if err != nil {
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TopicRegister) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Topics)))
	for za0001 := range z.Topics {
		o = msgp.AppendString(o, z.Topics[za0001])
	}
	o = msgp.AppendUint(o, z.Idx)
	o = msgp.AppendBytes(o, z.Pong)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TopicRegister) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		return
	}
	if cap(z.Topics) >= int(zb0002) {
		z.Topics = (z.Topics)[:zb0002]
	} else {
		z.Topics = make([]string, zb0002)
	}
	for za0001 := range z.Topics {
		z.Topics[za0001], bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			return
		}
	}
	z.Idx, bts, err = msgp.ReadUintBytes(bts)
	if err != nil {
		return
	}
	z.Pong, bts, err = msgp.ReadBytesBytes(bts, z.Pong)
	if err != nil {
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TopicRegister) Msgsize() (s int) {
	s = 1 + msgp.ArrayHeaderSize
	for za0001 := range z.Topics {
		s += msgp.StringPrefixSize + len(z.Topics[za0001])
	}
	s += msgp.UintSize + msgp.BytesPrefixSize + len(z.Pong)
	return
}
